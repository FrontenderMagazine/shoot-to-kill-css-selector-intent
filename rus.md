Огонь на поражение; правильная цель для CSS селектора
==========================================================

Я расстраиваюсь каждый раз, когда вижу, что кто-то написал неправильный
селектор. Неправильно назначенный селектор равносилен ковровой 
бомбардировке — его цель слишком общая. Селектор `.header ul{}`
против `.main-nav{}`, `.widget h2{}` против `.widget-title`, `article > p
:first-child{}` легко заменяем на `.intro{}`. Всё это недостаточно точные
селекторы.

Рассмотрим пример с селектором `.header ul{}`. Предположим, что `ul` — главное
меню на нашем сайте. Как вы и ожидаете, меню находится в шапке сайта и сейчас
это единственный `ul` в этом блоке. `.header ul{}` — хороший селектор,
верно? **Не совсем**. Я имею ввиду, что он, может быть, и работает, но
недостаточно хорошо. Этот селектор недальновиден и решительно неточен. Как
только мы добавим ещё один `ul` в шапку, к нему применятся все стили нашего 
главного меню, и, скорее всего, это не то, что мы хотели. 
Всё это приведёт к рефакторингу большого количества кода *или* к вынужденному 
сбрасыванию стилей для нового `ul`, чтобы избавить от артефактов слишком общего селектора.

Цель селектора должна совпадать с причиной, по которой вы решили что-то
стилизовать; спросите себя: **«Я пишу этот селектор, потому что мне нужно
выбрать `ul` внутри `.header` или, потому что я хочу выделить главное меню?»**
Ответ на этот вопрос и определит селектор.


## Это всё из-за ключевых селекторов… ##

Вы спросите, что определяет цель селектора? И я отвечу, что эту роль
играет ключевой селектор. Ключевой селектор — это последний селектор перед
открывающейся фигурной скобкой `{`. Это очень важная деталь в мире CSS, в
котором ***браузеры читают селекторы справа налево***.

	.header ul      { /* Ключевой селектор — ‘ul’ */ }
	.ul li a        { /* Ключевой селектор — ‘a’ */ }
	p:last-child    { /* Ключевой селектор — ‘:last-child’ */ }

Я уже обсуждал в своей статье [«Как писать CSS-селекторы, эффективные с точки зрения
производительности»][1], что ключевой селектор играет главную
роль в эффективном CSS, но всё же не стоит забывать, что цель селектора должна
влиять на выбор селектора. `html > body > section.content > article span{}`
витиеватый до нелепости и настолько ужасный селектор, что я уверен, что никто
и никогда такой селектор и не писал, правда?. Но даже несмотря на опасность и
огромный вес этого селектора, его ключевой селектор по прежнему `span` — 
**слишком общий**. По большому счёту без разницы, что вы пишете до ключевого
селектора: ключевой селектор — единственное, что должно вас волновать.

Возьмите за **правило**, что вы постараетесь никогда не использовать
селектор по тегу для ключевого селектора (обычно, это элемент типа `ul` или
`span`) и также не используйте для этой цели базовые объекты (`.nav` или
`.media`). Только по причине того, что `.media` находится в контентной области
не означает того, что этот блок будет там всегда.

Давайте посмотрим на пример с `.header ul{}` и предположим, что наша разметка
выглядит так, как если бы мы использовали [nav абстракцию][2].

	<div class=header>
	
		<ul class=nav>
			[ссылки]
		</ul>
	
	</div>

Мы можем выбрать это несколькими способами:

	.header ul{
		[Стили для главного меню]
	}

Это плохо, так как сразу после добавления ещё хоть одного `ul` в шапку они
все будут выглядеть как главное меню. Эту опасную ситуацию легко исправить.

Затем мы попробуем:

	.header .nav{
		[Стили для главного меню]
	}

Это ненамного отличается от примера с `.header ul` и то совсем чуть-чуть.
Теперь мы можем добавлять `ul` ничем не рискуя, но невозможно добавить что-
либо ещё с `.nav` классом; добавление вложенного меню или хлебных крошек
однозначно превратится в кошмар!

В конце концов, лучшим решением нашей проблемы будет добавить второй класс к
элементу `ul` — `.main-nav`:

	<div class=header>
	
		<ul class="nav main-nav">
			[ссылки]
		</ul>
	
	</div>
	
	.main-nav{
		[Стили для главного меню]
	}

Это правильная цель для селектора: теперь мы выбираем элемент по **совершенно
верным** причинам, а не по случайным или косвенным обстоятельствам. В итоге
мы можем добавлять сколько угодно `ul` и `.nav` в `.header`, и пространство
стилей `.nav` никогда не будет стилизовать что-то по ошибке. Мы перестали быть
беспринципными бомбардировщиками.

Держите ваши селекторы точными и явными настолько, насколько вы можете,
предпочитая для этого классы. Применение уточняющих стилей по общему селектору
влечёт за собой опасности. Общий селектор должен нести с собой общую
стилизацию, поэтому, если вы хотите повлиять на конкретный элемент, то скорее
всего, вам необходимо добавить на него уточняющий класс. **Конкретная цель
требует явного и точного селектора.**


## Примеры из жизни ##

Хороший пример, в котором я спутал карты самому себе, это проект, сделанный
мной в Sky; У меня был простой селектор `#content table{}`. (Бррр, я даже
использовал ID). Этот селектор был неприятен по трём причинам; первоначально, в
нём используются ID, чего катастрофически [делать нельзя][3], затем этот
селектор имеет куда бо́льший вес, чем ему нужно и последняя, и самая важная
причина этот селектор слишком неточен. Я не хотел стилизовать эти таблицы
внутри `#content`, только **потому-то** они находятся внутри `#content`,
просто я написал такую разметку, и не подумав, решил именно по разметке их и
выбрать. Я *полностью* признаю свою вину.

Первые несколько недель всё шло хорошо, но потом неожиданно нам понадобилось
добавить таблицы в `#content`, которые бы отличались от уже существующих. Мой
предыдущий селектор был куда более общим. Теперь мне приходиться отменять
стили, что я задал для **каждой** таблицы внутри `#content` блоке. Эх, если бы
я только имел более точные селекторы, чем эти:

	#content table{
		[стили для первой таблицы]
	}
	#content .bar{
		[отмена стилей первой таблицы]
		[стили для второй таблицы]
	}

Мне следовало использовать:

	.foo{
		[стили для первой таблицы]
	}
	.bar{
		[стили для второй таблицы]
	}

В итоге **гораздо** меньше головной боли. Думая наперёд и о цели селектора, я
съэкономил бы себе кучу времени.

## Исключения ##

Без сомнений **всегда** есть исключения. Идеальной причиной для селектора
`.main-nav > li` может быть, что ключевым селектором **является** селектор по
тегу. Также превосходно использовать `a`, чтобы выбрать абсолютно все ссылки в
чём-нибудь наподобие этого:

	html{
		color:#333;
		background-color:#fff;
	}

	/* Инвертированная цветовая схема для рекламируемых товаров */
	.promo{
		color:#fff;
		background-color:#333;
	}
	.promo a{
		color:#fff;
		text-decoration:underline;
	}

Когда это обусловлено причиной, есть смысл использовать общий селектор, чтобы
например стилизовать каждый `а` в режиме ковровой бомбардировки.


## Заключение ##

В общем, вместо бомардировок, стреляйте на поражение, выбирайте точный
селектор. Убедитесь, что его ключевой селектор конкретен и понятен.

Внимательно думайте о том, почему вы пишите именно этот селектор и выбирайте
более точный и правильный селектор; переопределяйте под реальные цели
селекторов. Вы имели ввиду:

	.header em{}

или на самом деле:

	.tagline{}

Вы хотели выбрать

	.footer p{}

или выбрать нужно было:

	.copyright{}

Мудро выбрать форму:

	.sidebar form{}

или же безопаснее:

	.search-form{}

Следите и изучайте ваши селекторы; были ли вы достаточно точны? Выбирают ли
селекторы правильные элементы по правильным причинам или это просто стечение
обстоятельств? Стреляйте на поражение. Будьте CSS снайпером, а не
бомбардировщиком.

В связи с этим, если вы переключитесь с длинных селекторов `.header ul` на
селекторы похожие на `.main-nav` это уменьшит вес и увеличит эффективность
селекторов; победа и все счастливы!

Также следует заметить, что [Джонатан Снук][4] написал схожий материал под
названием [*«Длина селектора»*][5]…

[1]: http://csswizardry.com/2011/09/writing-efficient-css-selectors/ "Writing efficient CSS selectors"
[2]: http://csswizardry.com/2011/09/the-nav-abstraction/ "The ‘nav’ abstraction"
[3]: http://csswizardry.com/2011/09/when-using-ids-can-be-a-pain-in-the-class/ "When using IDs can be a pain in the class.."
[4]: https://twitter.com/snookca "@snookca"
[5]: http://smacss.com/book/applicability "Depth of Applicability"
